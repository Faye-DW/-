# 图论与图算法

## 图的定义

图是由节点的集合V（vertex）与边(edge)的集合E组成的二元组，记G=（V,E）

图的分类：有向图与有向图:换言之，无向图的边是双向的

​		   无权图与有权图：权的物理意义：两个节点之间的距离…

图的数据结构表示：

临阶表：通过节点相连而形成的链表；

临界矩阵：$a_{ij}$表示第i个节点与第j个节点之间是否相连以及边的权重

## 图中的路径

1.从一个节点到另一个节点可以由边联通起来，那么这两个节点之间存在路径，路径的长度是边的权重之和。路径可以由路径上的节点来表示，也可以用路径上的边来表示。

2.简单路径：如果路径上没有相同的节点，那么这个路径是一个简单路径。

3.最短路径:连接两个节点的最短路径.

### 单源最短路径问题

输入一个图G(V,E)和一个节点i,输出为从i节点到图中每一个节点的最短路径 

| vertex  | dist | path    |
| ------- | ---- | ------- |
| $v_{1}$ | 2    | $v_{3}$ |
| $v_{5}$ | 4    | $v_{6}$ |
| $v_{3}$ | 5    | $v_{7}$ |

vertex表示从节点i到达$v_{i}$节点的最短路径，path表示与$v_{i}$相连的最短路径上的节点，通过这张表格，可以找到到达每一个节点的最短路径。

#### 无权图中的单源最短路径

对于无权图，每条边的权都是1

输入G=(E,V)和起始节点s，初始化一个空队列queue(),初始化一张表格

> vertex表示访问到的节点
>
> visit表示是否有访问过这个节点
>
> dist表示从s到$v_{i}$的距离
>
> path表示到达$v_{i}$前的节点是哪个

| vertex    | visit | dist     | path |
| --------- | ----- | -------- | ---- |
| $v_{1}$   | false | $\infin$ | 0    |
| $v_{2}$   | false | $\infin$ | 0    |
| …         | …     | …        | …    |
| …         | …     | …        | …    |
| $v_{n-1}$ | false | $\infin$ | 0    |
| $v_{n}$   | false | $\infin$ | 0    |

``````c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
	G={V,E};
    vertex s;
    queue<vertex> q;
    q.push(s);
    while (!q.empty())
    {
		vertex now=q.front();
        set<vertex> s={v;E[u][v]&&!visit[v]};
        while (s.size()--)
        {
			q.push(v);
            visit[v]=1;
            dist[v]=dist[now]+1;
            path[v]=now;
        }
    }
    return dist[],path[];
    return 0;
}
``````

> 算法的时间复杂度为0(|E|+|V|),伪代码与算法正确性的证明可以参照算法导论。

#### 广度优先搜索树

#### 深度优先搜索

#### 有权图的单源最短路径 Dijkstra算法

<img src="../../Pictures/Screenshots/屏幕截图 2024-07-02 190433.png" style="zoom:50%;" />

对于Dijkstra算法，有一种动态规划的感觉，但是对于优先队列的使用是否有必要？是否可以用单调队列代替？

``````c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
	G=(V,E);
    vertex s;
    dist[]={INF};
    path[]={0};
    prority_queue q;
    q.push(s);
    dist[s]=0;
    path[s]=0;
    while (!q.empty())
    {
		vertex now=q.front();
        q.pop();
        set<vertex> s={v;E[now][v]=1};
        while (s.size()--)
        {
			if (dist[now]+E[now][v]<dist[v])
            {
                dist[v]=min(dist[v],dist[now]+E[now][v]);
                q.push(v);
            }
        }
    }
    return 0;
}
``````

> 不同于无权图的算法，即使节点已经被访问过，需要重新计算路径并更新dist为更小的值，
>
> 但是为什么需要使用优先队列？

> Dijkstra算法的时间复杂度：在优先队列上的操作次数为0(|E|+|V|)，使用小根堆来实现优先队列，时间复杂度为$log_{}{V}$.所以总的时间复杂度为0((|E|+|V|)*$log_{}{V}$)
#### 最大流问题
> 最大流问题应用于有向有权图，边的权重定义为管道的流量
> 最大流问题需要满足：1.flow<=capacity.2.从管道流出的等于从管道输入的水量
#### Naive 算法
输入是一个有向有权图G=(V,E),节点s,v表示最大流问题的起点与终点，E[u][v]代表u,v两个节点之间是否有联通路径，寻找一条从s通向v的简单路径，这条路径的最大通量取决于最短边的容量，
```capacity[u][v]-=min(capacity[][]);
   E[u][v]=0
```
删除容量为0的边，进入下一次循环（寻找一条简单同路）
